This script is to be used inside of the ChatGpt Codex Web Enviroment Manual Setup for the Setup Script
This isi what it will do:

Create the backend source structure first
Then create Cargo.toml (which can now find the source files)
Build will work without the "no targets specified" error
Handle cases where Docker isn't available in Codex
Provide a working development environment

```
#!/bin/bash
set -e

echo "🚀 Starting DocGen SaaS Setup..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_info() {
    echo -e "${YELLOW}ℹ${NC} $1"
}

# Update system packages
print_status "Updating system packages..."
sudo apt-get update -qq

# Install system dependencies
print_status "Installing system dependencies..."
sudo apt-get install -y -qq \
    build-essential \
    pkg-config \
    libssl-dev \
    postgresql-client \
    redis-tools \
    git \
    curl \
    wget \
    jq

# Install Rust
if ! command -v rustc &> /dev/null; then
    print_status "Installing Rust..."
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable
    source $HOME/.cargo/env
else
    print_status "Rust already installed"
fi

# Update Rust and install additional components
print_status "Updating Rust and installing components..."
source $HOME/.cargo/env
rustup update stable
rustup component add rustfmt clippy

# Install Node.js 20 via fnm (Fast Node Manager)
if ! command -v fnm &> /dev/null; then
    print_status "Installing fnm (Fast Node Manager)..."
    curl -fsSL https://fnm.vercel.app/install | bash
    export PATH="$HOME/.local/share/fnm:$PATH"
    eval "$(fnm env --use-on-cd)"
fi

# Set up fnm in current shell
export PATH="$HOME/.local/share/fnm:$PATH"
eval "$(fnm env --use-on-cd)" 2>/dev/null || true

# Install Node.js 20
print_status "Installing Node.js 20..."
fnm install 20
fnm use 20
fnm default 20

# Install pnpm
print_status "Installing pnpm..."
npm install -g pnpm@latest

# Install Docker Compose if Docker is available
if command -v docker &> /dev/null; then
    print_status "Docker found, installing Docker Compose..."
    sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 2>/dev/null || true
    sudo chmod +x /usr/local/bin/docker-compose 2>/dev/null || true
else
    print_info "Docker not found, skipping Docker Compose installation"
fi

# Create project structure
print_status "Creating project structure..."
mkdir -p docgen-saas/{backend/src/{api,models,services,utils},frontend/src/{components,pages,hooks,services,types},migrations,scripts,config,docs,.github/workflows}

cd docgen-saas

# Create backend/src/main.rs FIRST (before Cargo.toml to avoid the error)
print_status "Creating backend source files..."
cat > backend/src/main.rs << 'EOF'
use actix_web::{web, App, HttpServer, middleware};
use sqlx::postgres::PgPoolOptions;
use tracing::info;
use tracing_subscriber;

mod api;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt::init();
    
    // Load environment variables
    dotenv::dotenv().ok();
    
    info!("Starting DocGen SaaS server...");
    
    // Database connection
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgresql://docgen:docgen_pass@localhost:5432/docgen_db".to_string());
    
    let db = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await
        .expect("Failed to connect to database");
    
    info!("Connected to database");
    
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(db.clone()))
            .wrap(middleware::Logger::default())
            .wrap(
                actix_cors::Cors::default()
                    .allow_any_origin()
                    .allow_any_method()
                    .allow_any_header()
            )
            .route("/health", web::get().to(health_check))
            .route("/api/health", web::get().to(health_check))
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await
}

async fn health_check() -> &'static str {
    "OK"
}
EOF

# Create api module files
cat > backend/src/api/mod.rs << 'EOF'
pub mod auth;
pub mod projects;
EOF

# Create placeholder files for modules
touch backend/src/api/auth.rs
touch backend/src/api/projects.rs

# NOW create backend Cargo.toml (after source files exist)
cat > backend/Cargo.toml << 'EOF'
[package]
name = "docgen-saas"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "docgen-saas"
path = "src/main.rs"

[dependencies]
# Web Framework
actix-web = "4.4"
actix-ws = "0.2"
actix-cors = "0.6"

# Database
sqlx = { version = "0.7", features = ["postgres", "runtime-tokio-native-tls", "uuid", "time", "json"] }
redis = { version = "0.24", features = ["tokio-comp", "connection-manager"] }

# Async Runtime
tokio = { version = "1.35", features = ["full"] }

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Authentication
jsonwebtoken = "9.2"
bcrypt = "0.15"

# GitHub API
octocrab = "0.32"
git2 = "0.18"

# HTTP Client
reqwest = { version = "0.11", features = ["json", "stream"] }

# OpenAI
async-openai = "0.19"

# Utilities
uuid = { version = "1.6", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
dotenv = "0.15"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
base64 = "0.21"
anyhow = "1.0"
thiserror = "1.0"

[dev-dependencies]
actix-rt = "2.9"
EOF

# Create frontend package.json
cat > frontend/package.json << 'EOF'
{
  "name": "docgen-saas-frontend",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.21.0",
    "@tanstack/react-query": "^5.17.0",
    "@stripe/stripe-js": "^2.2.0",
    "@monaco-editor/react": "^4.6.0",
    "framer-motion": "^10.17.0",
    "lucide-react": "^0.303.0",
    "zustand": "^4.4.7",
    "axios": "^1.6.5",
    "react-hot-toast": "^2.4.1",
    "recharts": "^2.10.0",
    "date-fns": "^3.2.0",
    "zod": "^3.22.4",
    "clsx": "^2.1.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.0",
    "typescript": "^5.2.2",
    "vite": "^5.0.8"
  }
}
EOF

# Create .env.example
cat > .env.example << 'EOF'
# Database
DATABASE_URL=postgresql://docgen:docgen_pass@localhost:5432/docgen_db
REDIS_URL=redis://localhost:6379

# AI Services
OPENAI_API_KEY=sk-...
CLAUDE_API_KEY=sk-ant-...

# GitHub
GITHUB_TOKEN=ghp_...
GITHUB_OWNER=your-github-username

# Stripe
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLIC_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Security
JWT_SECRET=your-256-bit-secret-key-here
ENCRYPTION_KEY=your-encryption-key-here

# App
FRONTEND_URL=http://localhost:3000
API_URL=http://localhost:8080
EOF

# Copy .env.example to .env
cp .env.example .env

# Create docker-compose.yml
cat > docker-compose.yml << 'EOF'
version: '3.9'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: docgen_db
      POSTGRES_USER: docgen
      POSTGRES_PASSWORD: docgen_pass
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U docgen"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
EOF

# Create initial migration
cat > migrations/001_initial_schema.sql << 'EOF'
-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Users table
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(255),
    stripe_customer_id VARCHAR(255),
    subscription_tier VARCHAR(50) DEFAULT 'free',
    subscription_status VARCHAR(50) DEFAULT 'active',
    api_key VARCHAR(255) UNIQUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Projects table
CREATE TABLE IF NOT EXISTS projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    github_repo VARCHAR(255),
    initial_prompt TEXT NOT NULL,
    status VARCHAR(50) DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Documents table
CREATE TABLE IF NOT EXISTS documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    doc_type VARCHAR(50) NOT NULL,
    content TEXT NOT NULL,
    version INTEGER DEFAULT 1,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Generation jobs table
CREATE TABLE IF NOT EXISTS generation_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
    step VARCHAR(50) NOT NULL,
    status VARCHAR(50) DEFAULT 'pending',
    error TEXT,
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_projects_user_id ON projects(user_id);
CREATE INDEX IF NOT EXISTS idx_documents_project_id ON documents(project_id);
CREATE INDEX IF NOT EXISTS idx_generation_jobs_project_id ON generation_jobs(project_id);
EOF

# Create Makefile
cat > Makefile << 'EOF'
.PHONY: help setup dev build test clean docker-up docker-down

help:
	@echo "Available commands:"
	@echo "  make setup       - Initial setup"
	@echo "  make dev         - Start development environment"
	@echo "  make build       - Build for production"
	@echo "  make test        - Run tests"
	@echo "  make clean       - Clean build artifacts"
	@echo "  make docker-up   - Start Docker services"
	@echo "  make docker-down - Stop Docker services"

setup: docker-up
	@echo "Setting up development environment..."
	@sleep 5
	cd backend && cargo build || true
	cd frontend && pnpm install

dev:
	@echo "Starting development servers..."
	make docker-up
	@echo "Starting backend on http://localhost:8080"
	cd backend && cargo run &
	@echo "Starting frontend on http://localhost:3000"
	cd frontend && pnpm dev

docker-up:
	@echo "Starting Docker services..."
	@if command -v docker-compose &> /dev/null; then \
		docker-compose up -d postgres redis; \
	else \
		echo "Docker Compose not available, skipping..."; \
	fi

docker-down:
	@echo "Stopping Docker services..."
	@if command -v docker-compose &> /dev/null; then \
		docker-compose down; \
	else \
		echo "Docker Compose not available, skipping..."; \
	fi

build:
	@echo "Building for production..."
	cd backend && cargo build --release
	cd frontend && pnpm build

test:
	@echo "Running tests..."
	cd backend && cargo test
	@echo "Frontend tests would run here"

clean:
	@echo "Cleaning build artifacts..."
	cd backend && cargo clean
	cd frontend && rm -rf dist node_modules
EOF

# Create README
cat > README.md << 'EOF'
# DocGen SaaS

AI-powered project documentation and GitHub scaffolding platform.

## Quick Start

1. **Setup environment:**
   ```bash
   make setup
   ```

2. **Configure API keys:**
   Edit `.env` file with your API keys

3. **Start development:**
   ```bash
   make dev
   ```

4. **Access the application:**
   - Frontend: http://localhost:3000
   - Backend API: http://localhost:8080

## Features

- ✨ AI-powered documentation generation
- 📁 Complete project scaffolding
- 🔄 GitHub repository creation
- 📊 Interactive schema visualization
- 💳 Stripe subscription management
- 🔐 JWT authentication

## Tech Stack

- **Backend:** Rust (Actix-web)
- **Frontend:** React + TypeScript
- **Database:** PostgreSQL
- **Cache:** Redis
- **AI:** OpenAI + Claude

## Development

Run individual services:
```bash
# Backend only
cd backend && cargo run

# Frontend only
cd frontend && pnpm dev
```

## License

Proprietary - All rights reserved
EOF

# Now install backend dependencies (after main.rs exists)
print_status "Building Rust backend..."
cd backend
cargo build 2>/dev/null || print_info "Initial cargo build may fail without all dependencies, this is normal"
cd ..

# Install frontend dependencies
print_status "Installing frontend dependencies..."
cd frontend

# Create vite config
cat > vite.config.ts << 'EOF'
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
      },
    },
  },
})
EOF

# Create tailwind config
cat > tailwind.config.js << 'EOF'
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
EOF

# Create postcss config
cat > postcss.config.js << 'EOF'
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
EOF

# Create TypeScript config
cat > tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
EOF

# Create tsconfig.node.json
cat > tsconfig.node.json << 'EOF'
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
EOF

# Create main.tsx
cat > src/main.tsx << 'EOF'
import React from 'react'
import ReactDOM from 'react-dom/client'
import { App } from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
EOF

# Create App.tsx
cat > src/App.tsx << 'EOF'
import React, { useEffect, useState } from 'react'

export const App: React.FC = () => {
  const [health, setHealth] = useState<string>('checking...')
  
  useEffect(() => {
    fetch('http://localhost:8080/api/health')
      .then(res => res.text())
      .then(data => setHealth(data))
      .catch(() => setHealth('Backend not connected'))
  }, [])
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
      <div className="container mx-auto p-8">
        <div className="max-w-4xl mx-auto">
          <h1 className="text-5xl font-bold text-center text-gray-800 mb-4">
            DocGen SaaS
          </h1>
          <p className="text-center text-gray-600 text-lg mb-8">
            AI-powered project documentation generator
          </p>
          
          <div className="bg-white rounded-lg shadow-lg p-6">
            <h2 className="text-2xl font-semibold mb-4">System Status</h2>
            <div className="space-y-2">
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded">
                <span className="font-medium">Frontend</span>
                <span className="text-green-600">✓ Running</span>
              </div>
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded">
                <span className="font-medium">Backend API</span>
                <span className={health === 'OK' ? 'text-green-600' : 'text-red-600'}>
                  {health === 'OK' ? '✓ Connected' : '✗ ' + health}
                </span>
              </div>
            </div>
          </div>
          
          <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
            <div className="bg-white rounded-lg shadow p-6">
              <h3 className="font-semibold text-lg mb-2">Step 1</h3>
              <p className="text-gray-600">Describe your project</p>
            </div>
            <div className="bg-white rounded-lg shadow p-6">
              <h3 className="font-semibold text-lg mb-2">Step 2</h3>
              <p className="text-gray-600">AI generates documentation</p>
            </div>
            <div className="bg-white rounded-lg shadow p-6">
              <h3 className="font-semibold text-lg mb-2">Step 3</h3>
              <p className="text-gray-600">Deploy to GitHub</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
EOF

# Create index.css
cat > src/index.css << 'EOF'
@tailwind base;
@tailwind components;
@tailwind utilities;
EOF

# Create index.html
cat > index.html << 'EOF'
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DocGen SaaS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
EOF

# Install frontend packages
pnpm install
cd ..

# Create .gitignore
cat > .gitignore << 'EOF'
# Dependencies
node_modules/
target/
dist/

# Environment
.env
.env.local

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Logs
*.log

# Build
*.tsbuildinfo

# Database
postgres_data/
EOF

# Create a simple run script
cat > run.sh << 'EOF'
#!/bin/bash
echo "Starting DocGen SaaS..."

# Start Docker services if available
if command -v docker-compose &> /dev/null; then
    echo "Starting Docker services..."
    docker-compose up -d postgres redis
    sleep 5
fi

# Start backend
echo "Starting backend server..."
cd backend && cargo run &
BACKEND_PID=$!

# Start frontend
echo "Starting frontend..."
cd ../frontend && pnpm dev &
FRONTEND_PID=$!

echo ""
echo "Services running:"
echo "  Frontend: http://localhost:3000"
echo "  Backend:  http://localhost:8080"
echo ""
echo "Press Ctrl+C to stop all services"

# Wait for Ctrl+C
trap "kill $BACKEND_PID $FRONTEND_PID; docker-compose down; exit" INT
wait
EOF

chmod +x run.sh

# Try to start Docker services if available
if command -v docker &> /dev/null && command -v docker-compose &> /dev/null; then
    print_status "Starting Docker services..."
    docker-compose up -d postgres redis 2>/dev/null || print_info "Docker services not started (Docker might not be available)"
    
    # Wait for services and run migrations
    if docker-compose ps | grep -q "postgres"; then
        print_status "Waiting for PostgreSQL..."
        sleep 10
        print_status "Running database migrations..."
        PGPASSWORD=docgen_pass psql -h localhost -U docgen -d docgen_db -f migrations/001_initial_schema.sql 2>/dev/null || print_info "Migrations will run when database is available"
    fi
else
    print_info "Docker not available in this environment - you'll need to set up PostgreSQL and Redis manually"
fi

# Create GitHub workflow
cat > .github/workflows/ci.yml << 'EOF'
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
    
    - name: Backend tests
      run: |
        cd backend
        cargo test
    
    - name: Frontend build
      run: |
        cd frontend
        npm install -g pnpm
        pnpm install
        pnpm build
EOF

# Success message
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
print_status "DocGen SaaS setup complete! 🎉"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""
echo "Project created in: $(pwd)"
echo ""
echo "Quick start:"
echo "  1. Edit .env file with your API keys"
echo "  2. Run: ./run.sh"
echo ""
echo "Or manually:"
echo "  Backend:  cd backend && cargo run"
echo "  Frontend: cd frontend && pnpm dev"
echo ""
echo "Access points:"
echo "  Frontend:  http://localhost:3000"
echo "  Backend:   http://localhost:8080"
echo ""
print_info "Happy coding! 🚀"

```

